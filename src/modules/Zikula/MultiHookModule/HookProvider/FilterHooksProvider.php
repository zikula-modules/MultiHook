<?php
/**
 * MultiHook.
 *
 * @copyright Zikula Team (Zikula)
 * @license http://www.gnu.org/licenses/lgpl.html GNU Lesser General Public License
 * @author Zikula Team <info@ziku.la>.
 * @link https://ziku.la
 * @version Generated by ModuleStudio 1.4.0 (https://modulestudio.de).
 */

namespace Zikula\MultiHookModule\HookProvider;

use Symfony\Component\HttpFoundation\RequestStack;
use Zikula\Bundle\HookBundle\Hook\FilterHook;
use Zikula\ExtensionsModule\Api\ApiInterface\VariableApiInterface;
use Zikula\MultiHookModule\Collector\EntryProviderCollector;
use Zikula\MultiHookModule\Collector\NeedleCollector;
use Zikula\MultiHookModule\Helper\HookHelper;
use Zikula\MultiHookModule\Helper\PermissionHelper;
use Zikula\MultiHookModule\HookProvider\Base\AbstractFilterHooksProvider;
use Zikula\ThemeModule\Api\ApiInterface\PageAssetApiInterface;
use Zikula\ThemeModule\Engine\Asset;

/**
 * Implementation class for filter hooks provider.
 */
class FilterHooksProvider extends AbstractFilterHooksProvider
{
    /**
     * @var RequestStack
     */
    private $requestStack;

    /**
     * @var VariableApiInterface
     */
    private $variableApi;

    /**
     * @var EntryProviderCollector
     */
    protected $entryProviderCollector;

    /**
     * @var NeedleCollector
     */
    protected $needleCollector;

    /**
     * @var HookHelper
     */
    private $hookHelper;

    /**
     * @var PageAssetApiInterface
     */
    private $pageAssetApi;

    /**
     * @var Asset
     */
    private $assetHelper;

    public function setRequestStack(RequestStack $requestStack)
    {
        $this->requestStack = $requestStack;
    }

    public function setVariableApi(VariableApiInterface $variableApi)
    {
        $this->variableApi = $variableApi;
    }

    public function setEntryProviderCollector(EntryProviderCollector $entryProviderCollector)
    {
        $this->entryProviderCollector = $entryProviderCollector;
    }

    public function setNeedleCollector(NeedleCollector $needleCollector)
    {
        $this->needleCollector = $needleCollector;
    }

    public function setHookHelper(HookHelper $hookHelper)
    {
        $this->hookHelper = $hookHelper;
    }

    public function setPermissionHelper(PermissionHelper $permissionHelper)
    {
        $this->permissionHelper = $permissionHelper;
    }

    public function setPageAssetApi(PageAssetApiInterface $pageAssetApi)
    {
        $this->pageAssetApi = $pageAssetApi;
    }

    public function setAssetHelper(Asset $assetHelper)
    {
        $this->assetHelper = $assetHelper;
    }

    /**
     * @inheritDoc
     */
    public function applyFilter(FilterHook $hook)
    {
        $request = $this->requestStack->getCurrentRequest();

        // check the user agent - if it is a bot, return immediately to avoid performance impact
        $robotslist = [
            'ia_archiver',
            'googlebot',
            'mediapartners-google',
            'yahoo!',
            'msnbot',
            'bingbot',
            'jeeves',
            'lycos'
        ];
        $userAgent = $request->server->get('HTTP_USER_AGENT');
        for ($cnt = 0; $cnt < count($robotslist); $cnt++) {
            if (false !== strpos(strtolower($userAgent), $robotslist[$cnt])) {
                return;
            }
        }

        // add custom styles (for older browsers)
        $this->pageAssetApi->add('stylesheet', $this->assetHelper->resolve('@ZikulaMultiHookModule:css/custom.css'));

        $text = $hook->getData();
        //dump($text);

        // pad it with a space so we can distinguish between FALSE and matching the 1st char (index 0).
        $text = ' ' . $text;

        static $search = [];
        static $replace = [];
        static $finalsearch = [];
        static $finalreplace = [];
        static $gotAbbreviations = 0;
        static $gotNeedles = 0;

        static $mhAdmin;
        if (!isset($mhAdmin)) {
            $mhAdmin = $this->permissionHelper->hasPermission(ACCESS_DELETE);
        }

        $applyReplacementsToCodeTags = $this->variableApi->get('ZikulaMultiHookModule', 'applyReplacementsToCodeTags', false);
        $showEditLink = $mhAdmin && $this->variableApi->get('ZikulaMultiHookModule', 'showEditLink', true);
        $replaceOnlyFirstInstanceOfItems = $this->variableApi->get('ZikulaMultiHookModule', 'replaceOnlyFirstInstanceOfItems', false);
        $replaceCensoredWordsWhenTheyArePartOfOtherWords = $this->variableApi->get('ZikulaMultiHookModule', 'replaceCensoredWordsWhenTheyArePartOfOtherWords', false);
        $doNotCensorFirstAndLastLetterInWordsWithMoreThanTwoChars = $this->variableApi->get('ZikulaMultiHookModule', 'doNotCensorFirstAndLastLetterInWordsWithMoreThanTwoChars', false);

        $replaceAbbreviations = $this->variableApi->get('ZikulaMultiHookModule', 'replaceAbbreviations', true);
        $replaceAcronyms = $this->variableApi->get('ZikulaMultiHookModule', 'replaceAcronyms', true);
        $replaceLinks = $this->variableApi->get('ZikulaMultiHookModule', 'replaceLinks', true);
        $replaceCensoredWords = $this->variableApi->get('ZikulaMultiHookModule', 'replaceCensoredWords', true);
        $replaceNeedles = $this->variableApi->get('ZikulaMultiHookModule', 'replaceNeedles', true);

        $entryTypes = [];
        if (true === $replaceAbbreviations) {
            $entryTypes[] = 'abbr';
        }
        if (true === $replaceAcronyms) {
            $entryTypes[] = 'acronym';
        }
        if (true === $replaceLinks) {
            $entryTypes[] = 'link';
        }
        if (true === $replaceCensoredWords) {
            $entryTypes[] = 'censor';
        }

        // deal with munded words (leet speak)
        $leetsearch  = ['/o/i', '/e/i', '/a/i', '/i/i'];
        $leetreplace = ['0', '3', '@', '1'];

        // base url for making links absolute if needed
        $baseUrl = $request->getSchemeAndHttpHost() . $request->getBasePath();

        // Step 0 - remove areas that should not be changed, eg. for the zdebug plugin
        //          those areas are marked with <!--raw-->some hml<!--/raw-->
        $rawcount = preg_match_all("/<!--raw-->(.*)<!--\/raw-->/Usi", $text, $raws);
        for ($i = 0; $i < $rawcount; $i++) {
            $text = substr_replace($text, " MULTIHOOKRAWREPLACEMENT{$i} ", strpos($text, $raws[0][$i]), strlen($raws[0][$i]));
        }

        // Step 1 - move all bbcode with [code][/code] out of the way
        //          if MultiHook is configured accordingly
        if (false === $applyReplacementsToCodeTags) {
            // if we are faster than bbcode, we will have to remove the code tags
            $codecount1 = preg_match_all("/\[code(.*)\](.*)\[\/code\]/siU", $text, $codes1);
            for ($i = 0; $i < $codecount1; $i++) {
                $text = str_replace($codes1[0][$i], " MULTIHOOKCODE1REPLACEMENT{$i} ", $text);
                //$text = preg_replace('/(' . preg_quote($codes1[0][$i], '/') . ')/', " MULTIHOOKCODE1REPLACEMENT{$i} ", $text, 1);
            }
            // but bbcode may have been faster than we are; to avoid any problems its embraces the
            // replaced code tags with <!--code--> and <!--/code-->
            // this is what we are taking care of now
            $codecount2 = preg_match_all("/<!--code-->(.*)<!--\/code-->/siU", $text, $codes2);
            for ($i = 0; $i < $codecount2; $i++) {
                $text = str_replace($codes2[0][$i], " MULTIHOOKCODE2REPLACEMENT{$i} ", $text);
                //$text = preg_replace('/(' . preg_quote($codes2[0][$i], '/') . ')/', " MULTIHOOKCODE2REPLACEMENT{$i} ", $text, 1);
            }
        }

        // Step 2 - move all links out of the text and replace them with placeholders
        $tagcount = preg_match_all('/<a(.*)>(.*)<\/a>/siU', $text, $tags);
        for ($i = 0; $i < $tagcount; $i++) {
            $text = preg_replace('/(' . preg_quote($tags[0][$i], '/') . ')/', " MULTIHOOKTAGREPLACEMENT{$i} ", $text, 1);
        }

        // Step 3 - remove all html tags, we do not want to change them!!
        $htmlcount = preg_match_all("/<(?:[^\"\']+?|.+?(?:\"|\').*?(?:\"|\')?.*?)*?>/si", $text, $html);
        for ($i = 0; $i < $htmlcount; $i++) {
            $text = preg_replace('/(' . preg_quote($html[0][$i], '/') . ')/', " MULTIHOOKHTMLREPLACEMENT{$i} ", $text, 1);
        }

        // Step 4 - move all bbcode with [url][/url] out of the way
        $urlcount = preg_match_all("#\[url(.*)\](.*)\[\/url\]#siU", $text, $urls);
        for ($i = 0; $i < $urlcount; $i++) {
            $text = preg_replace('/(' . preg_quote($urls[0][$i], '/') . ')/', " MULTIHOOKURLREPLACEMENT{$i} ", $text, 1);
        }

        // Step 5 - move all urls starting with http:// etc. out of the way
        $linkcount = preg_match_all("/(http|https|ftp|ftps|news)\:\/\/([a-zA-Z0-9\-\._]+[\.]{1}[a-zA-Z]{2,6})(\/[a-zA-Z0-9\-\.\?\,\'\/\\\+&%\$#_=~]+)?/siU", $text, $links);
        for ($i = 0; $i < $linkcount; $i++) {
            $text = preg_replace('/(' . preg_quote($links[0][$i], '/') . ')/', " MULTIHOOKLINKREPLACEMENT{$i} ", $text, 1);
        }

        // Step 6 - move hilite hook additions out of the text
        $hilitecount = preg_match_all("/<!--hilite-->(.*)<!--\/hilite-->/siU", $text, $hilite);
        for ($i = 0; $i < $hilitecount; $i++) {
            $text = preg_replace('/(' . preg_quote($hilite[0][$i], '/') . ')/', " MULTIHOOKHILITEREPLACEMENT{$i} ", $text, 1);
        }

        if (empty($gotAbbreviations)) {
            $gotAbbreviations = 1;
            $entries = [];
            foreach ($this->entryProviderCollector->getActive() as $entryProvider) {
                $providedEntries = $entryProvider->getEntries($entryTypes);
                foreach ($providedEntries as $entry) {
                    $entries[] = $entry;
                }
            }

            // Create search/replace array from abbreviations/links information
            foreach ($entries as $entry) {
                // check if the current tmp is a link
                //save original long
                $entry['long_original'] = $entry['longform'];
                if ('link' == $entry['type']) {
                    $entry['longform'] = $this->hookHelper->createAbsoluteUrl($entry['longform'], $baseUrl);
                }

                $entry['longform'] = preg_replace('/(\b)/', '\\1MULTIHOOKTEMPORARY', $entry['longform']);
                $entry['title'] = preg_replace('/(\b)/', '\\1MULTIHOOKTEMPORARY', $entry['title']);

                if ('abbr' == $entry['type']) {
                    $search_temp = '/(?<![\/\w@\.:])(' . preg_quote($entry['shortform'], '/'). ')(?![\/\w@])(?!\.\w)/i';
                    $search[] = $search_temp;
                    $replace[] = md5($search_temp);
                    $finalsearch[] = '/' . preg_quote(md5($search_temp), '/') . '/';
                    $finalreplace[] = $this->hookHelper->createAbbr($entry, $showEditLink);
                    unset($search_temp);
                } elseif ('acronym' == $entry['type']) {
                    $search_temp = '/(?<![\/\w@\.:])(' . preg_quote($entry['shortform'], '/'). ')(?![\/\w@])(?!\.\w)/i';
                    $search[] = $search_temp;
                    $replace[] = md5($search_temp);
                    $finalsearch[] = '/' . preg_quote(md5($search_temp), '/') . '/';
                    $finalreplace[] = $this->hookHelper->createAcronym($entry, $showEditLink);
                    unset($search_temp);
                } elseif ('link' == $entry['type']) {
                    // don't show link if the target is the current url
                    if (in_array($entry['long_original'], [$request->getUri(), $request->getRequestUri()])) {
                        continue;
                    }

                    // if short beginns with a single ' we need another regexp to not check for \w
                    // this enables autolinks for german deppenapostrophs :-)
                    if ($entry['shortform'][0] == '\'') {
                        $search_temp = '/(?<![\/@\.:-])(' . preg_quote($entry['shortform'], '/'). ')(?![\/\w@-])(?!\.\w)/i';
                    } else {
                        $search_temp = '/(?<![\/\w@\.:-])(' . preg_quote($entry['shortform'], '/'). ')(?![\/\w@:-])(?!\.\w)/i';
                    }
                    $search[] = $search_temp;
                    $replace[] = md5($search_temp);
                    $finalsearch[] = '/' . preg_quote(md5($search_temp), '/') . '/';
                    $finalreplace[] = $this->hookHelper->createLink($entry, $showEditLink);
                    unset($search_temp);
                } elseif ('censor' == $entry['type']) {
                    // original censored word
                    if (false === $replaceCensoredWordsWhenTheyArePartOfOtherWords) {
                        $search_temp = '/(?<![\/\w@\.:])(' . preg_quote($entry['shortform'], '/'). ')(?![\/\w@])(?!\.\w)/i';
                    } else {
                        $search_temp = '/(?)(' . preg_quote($entry['shortform'], '/') . ')(?)/i';
                    }
                    $search[] = $search_temp;
                    $replace[] = md5($search_temp);
                    $finalsearch[] = '/' . preg_quote(md5($search_temp), '/') . '/';
                    $finalreplace[] = $this->hookHelper->createCensor($entry, $showEditLink, $doNotCensorFirstAndLastLetterInWordsWithMoreThanTwoChars);

                    // Common replacements
                    $mungedword = preg_replace($leetsearch, $leetreplace, $entry['shortform']);
                    if ($mungedword != $entry['shortform']) {
                        $search_temp = '/(?<![\/\w@\.:])(' . preg_quote($mungedword, '/'). ')(?![\/\w@])(?!\.\w)/i';
                        $search[] = $search_temp;
                        $replace[] = md5($search_temp);
                        $finalsearch[] = '/' . preg_quote(md5($search_temp), '/') . '/';
                        $finalreplace[] = $this->hookHelper->createCensor($entry, $showEditLink, $doNotCensorFirstAndLastLetterInWordsWithMoreThanTwoChars);
                    }
                    unset($search_temp);
                }
            }
        }

        for ($i = 0; $i < $linkcount; $i++) {
            $text = preg_replace("/ MULTIHOOKLINKREPLACEMENT{$i} /", $links[0][$i], $text, 1);
        }

        if (true === $replaceNeedles) {
            // check for needles
            if (empty($gotNeedles)) {
                $gotNeedles = 1;
                $needles = $this->needleCollector->getActive();
                if (count($needles) > 0) {
                    foreach ($needles as $needle) {
                        $subjects = method_exists($needle, 'getSubjects') ? $needle->getSubjects() : [];
                        if (!is_array($subjects)) {
                            $subjects = [$subjects];
                        }
                        $regExpModifier = method_exists($needle, 'isCaseSensitive') && false === $needle->isCaseSensitive() ? 'i' : '';
                        foreach ($subjects as $subject) {
                            preg_match_all('/(?<![\/\w@\.:])' . preg_quote(strtoupper($subject), '/') . '([a-zA-Z0-9\.\?\/&:=_-]*?)(?![\/\?\w&@:=_-])(?!\.\w)/' . $regExpModifier, $text, $needleResults);
                            if (is_array($needleResults) && count($needleResults[0]) > 0) {
                                // complete needle in $needleResults[0], needle id in $needleResults[1]
                                // both are arrays
                                for ($ncnt = 0; $ncnt < count($needleResults[0]); $ncnt++) {
                                    $search_temp = '/(?<![\/\w@\.:])(' . preg_quote($needleResults[0][$ncnt], '/'). ')(?![\/\w@:-])(?!\.\w)/';
                                    $search[] = $search_temp;
                                    $replace[] = md5($search_temp);
                                    $finalsearch[] = '/' . preg_quote(md5($search_temp), '/') . '/';

                                    $finalreplace[] = $needle->apply($needleresults[1][$ncnt], $subject);
                                    unset($search_temp);
                                }
                            }
                        }
                    }
                }
            }
        }

        // Step 7 - the main replacements
        if (true === $replaceOnlyFirstInstanceOfItems) {
            $text = preg_replace($search, $replace, $text, 1);
            $text = preg_replace($finalsearch, $finalreplace, $text, 1);
        } else {
            $text = preg_replace($search, $replace, $text);
            $text = preg_replace($finalsearch, $finalreplace, $text);
        }

        // Step 8 - replace the spaces we munged in preparation of step 6
        $text = str_replace('MULTIHOOKTEMPORARY', '', $text);

        // Step 9-15 - replace the tags that we removed before
        for ($i = 0; $i < $hilitecount; $i++) {
            $text = preg_replace("/ MULTIHOOKHILITEREPLACEMENT{$i} /", $hilite[0][$i], $text, 1);
        }
        /*
        for ($i = 0; $i < $linkcount; $i++) {
            $text = preg_replace("/ MULTIHOOKLINKREPLACEMENT{$i} /", $links[0][$i], $text, 1);
        }
        */
        for ($i = 0; $i < $urlcount; $i++) {
            $text = preg_replace("/ MULTIHOOKURLREPLACEMENT{$i} /", $urls[0][$i], $text, 1);
        }
        for ($i = 0; $i < $htmlcount; $i++) {
            $text = preg_replace("/ MULTIHOOKHTMLREPLACEMENT{$i} /", $html[0][$i], $text, 1);
        }
        for ($i = 0; $i < $tagcount; $i++) {
            $text = preg_replace("/ MULTIHOOKTAGREPLACEMENT{$i} /", $tags[0][$i], $text, 1);
        }

        if (false === $applyReplacementsToCodeTags) {
            for ($i = 0; $i < $codecount2; $i++) {
                $text = str_replace(" MULTIHOOKCODE2REPLACEMENT{$i} ", $codes2[0][$i], $text);
                //$text = preg_replace("/ MULTIHOOKCODE2REPLACEMENT{$i} /", $codes2[0][$i], $text, 1);
            }
            for ($i = 0; $i < $codecount1; $i++) {
                $text = str_replace(" MULTIHOOKCODE1REPLACEMENT{$i} ", $codes1[0][$i], $text);
                //$text = preg_replace("/ MULTIHOOKCODE1REPLACEMENT{$i} /", $codes1[0][$i], $text, 1);
            }
        }

        for ($i = 0; $i < $rawcount; $i++) {
            $text = str_replace(" MULTIHOOKRAWREPLACEMENT{$i} ", $raws[0][$i], $text);
        }

        // Remove our padding from the string
        $text = substr($text, 1);

        //dump($text);
        $hook->setData($text);
    }
}
